#!/opt/puppetlabs/puppet/bin/ruby

require "net/https"
require "json"
require "uri"
require 'time'
require 'optparse'
require 'yaml'

#===========================================================================#
# BUILD CONFIGURATION OPTIONS                                               #
#===========================================================================#

settings = { }
config = { }

OptionParser.new do |parser|
  parser.banner = "Usage: tk_metrics [options]"

  ident = lambda { |name,arg| config[name] = arg }
  list = lambda { |name,arg| config[name] = arg.split(',') }

  option = lambda do |name,opt,desc,save,default=nil|
    settings[name] = { default: default }
    parser.on(opt, desc) do |arg|
      save.call(name, arg)
    end
  end

  # Each possible configuration option is defined here
  option.call(:"output-dir", '--output-dir ARG', 'Directory to save output to', ident, false)
  option.call(:hosts, '--hosts ARG', 'Hosts to collect metrics from (comma-separated)', list, ['localhost'])
  option.call(:"additional-metrics", '--additional-metrics ARG', 'Additional metrics to collect (comma-separated)', list, [])
  option.call(:"metrics-port", '--metrics-port ARG', 'The port the metrics service runs on', ident)
  option.call(:clientcert, '--clientcert ARG', 'Not used', ident)
  option.call(:"pe-version", '--pe-version ARG', 'The version of PE in use', ident)
  option.call(:print, '--[no-]print ARG', 'Print to stdout', ident, true)
  option.call(:ssl, '--[no-]ssl ARG', 'Whether or not to use SSL when gather metrics', ident, true)

  # This one is special because it's required
  option.call(:"metrics-type", '--metrics-type ARG', 'Type of metric to collect', ident)

  # Kinda pointless to include descriptions unless there's a help flag
  parser.on("-h", "--help", "Prints this help") { puts parser; exit }

end.parse!

raise('ERROR: Missing configuration option "metrics-type"') if config[:"metrics-type"].nil?

begin
  file = File.join(File.dirname(File.expand_path(__FILE__)),"#{config[:"metrics-type"]}_config.yaml")
  file_config = YAML.load_file(file)
rescue Exception => e
  STDERR.puts "ERROR: unable to read configuration file from #{file}: #{e}"
  exit 1
end

# For the options which MAY be read from a config file, retrieve those values
# if they have not been specified during invocation. Values specified on the
# command line are given precedence.
settings.each do |opt,attrs|
  possibilities = [config[opt], file_config[opt], attrs[:default]]
  config[opt] = possibilities.find {|p| !p.nil? }
  raise("ERROR: Missing configuration option \"#{opt}\"") if config[opt].nil?
end

#===========================================================================#
# MAIN SCRIPT LOGIC                                                         #
#===========================================================================#

$error_array = []

def setup_connection(url, ssl)
  uri  = URI.parse(url)
  http = Net::HTTP.new(uri.host, uri.port)
  if ssl then
    http.use_ssl = true
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE
  end

  return http,uri
end

def get_endpoint(url,ssl)
  http,uri = setup_connection(url,ssl)

  data = JSON.parse(http.get(uri.request_uri).body)
rescue Exception => e
    $error_array << "#{e}"
    data = {}
end

def post_endpoint(url,post_data,ssl)
  http,uri = setup_connection(url,ssl)

  request = Net::HTTP::Post.new(uri.request_uri)
  request.content_type = 'application/json'
  request.body = post_data

  data = JSON.parse(http.request(request).body)
rescue Exception => e
    $error_array << "#{e}"
    data = {}
end

def generate_host_url(host, port, ssl)
  if ssl then
    protocol = 'https'
  else
    protocol = 'http'
  end

  host_url = "#{protocol}://#{host}:#{port}"
end

def get_status_endpoint(host, port, ssl)
  host_url = generate_host_url(host, port, ssl)

  status_endpoint = "#{host_url}/status/v1/services?level=debug"
  status_output   = get_endpoint(status_endpoint,ssl)
end

def bulk_retrieve_additional_metrics(host, port, metrics, ssl)
  host_url = generate_host_url(host, port, ssl)

  post_data = []
  metrics.each do |metric|
    post_data << metric['url']
  end

  endpoint = "#{host_url}/metrics/v1/mbeans"
  metrics_output = post_endpoint(endpoint, post_data.to_json, ssl)
  metrics_array = []

  metrics.each_index do |index|
    metric_name = metrics[index]['name']
    metric_data = metrics_output[index]

    metrics_array << { 'name' => metric_name,
                       'data' => metric_data  }
  end

  return metrics_array
end

def individually_retrieve_additional_metrics(host, port, metrics, ssl)
  host_url = generate_host_url(host, port, ssl)

  metrics_array = []
  metrics.each do |metric|
    endpoint = URI.escape("#{host_url}/metrics/v1/mbeans/#{metric['url']}")
    metrics_array <<  { 'name' => metric['name'],
                        'data' => get_endpoint(endpoint, ssl) }
  end

  return metrics_array
end

def retrieve_additional_metrics(host,port,metrics,pe_version, ssl)
  if Gem::Version.new(pe_version) < Gem::Version.new('2016.2.0') then
    metrics_array = individually_retrieve_additional_metrics(host, port, metrics, ssl)
  else
    metrics_array = bulk_retrieve_additional_metrics(host, port, metrics, ssl)
  end

  return metrics_array
end

filename = Time.now.utc.strftime('%Y%m%dT%H%M%SZ') + '.json'

config[:hosts].each do |host|
  begin
    timestamp = Time.now
    dataset = {'timestamp' => timestamp.utc.iso8601, 'servers' => {}}
    hostkey = host.gsub('.', '-')

    status_output   = get_status_endpoint(host, config[:"metrics-port"], config[:ssl])
    dataset['servers'][hostkey] = {config[:"metrics-type"] => status_output}

    unless config[:"additional-metrics"].empty? then
      metrics_array = retrieve_additional_metrics(host, config[:"metrics-port"], config[:"additional-metrics"], config[:"pe-version"], config[:ssl])

      metrics_array.each do |metric_hash|
        metric_name = metric_hash['name']
        metric_data = metric_hash['data']

        dataset['servers'][hostkey][config[:"metrics-type"]][metric_name] = metric_data
      end
    end

    dataset['servers'][hostkey][config[:"metrics-type"]]['error'] = $error_array
    dataset['servers'][hostkey][config[:"metrics-type"]]['error_count'] = $error_array.count
    dataset['servers'][hostkey][config[:"metrics-type"]]['api-query-start'] = timestamp.utc.iso8601
    dataset['servers'][hostkey][config[:"metrics-type"]]['api-query-duration'] = Time.now - timestamp

    json_dataset = JSON.pretty_generate(dataset)

    unless config[:"output-dir"] == false then
      Dir.chdir(config[:"output-dir"]) do
        Dir.mkdir(host) unless File.exist?(host)
        File.open(File.join(host, filename), 'w') do |file|
          file.write(json_dataset)
        end
      end
    end
    if config[:print] != false then
      STDOUT.write(json_dataset)
    end
  end
end
